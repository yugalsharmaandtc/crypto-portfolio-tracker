ğŸ§  Senior Developer's Thought Process & Build Order

ğŸ¯ How a Senior Developer THINKS Before Writing Code
Before touching the keyboard, a senior dev asks these questions:
1. What problem am I solving?
2. What data do I need to store?
3. Who will use this and how?
4. What external dependencies do I have?
5. What can break and how do I handle it?
6. How will this scale?
For our project the answers were:
1. Track crypto portfolio with real-time prices
2. Users + Portfolio holdings
3. Authenticated users via browser
4. CoinGecko free API + PostgreSQL
5. API rate limits, WebSocket disconnects, expired tokens
6. Stateless JWT, connection pooling, WebSocket manager

ğŸ“‹ THE EXACT ORDER A SENIOR DEV BUILDS THIS PROJECT
PHASE 1: Foundation (Backend Core)
PHASE 2: Data Layer (Models + Schemas)
PHASE 3: Business Logic (Services)
PHASE 4: API Layer (Endpoints)
PHASE 5: Frontend Foundation
PHASE 6: Frontend Features
PHASE 7: Integration + Testing

ğŸ—ï¸ PHASE 1: Foundation â€” "Set Up The Skeleton"
Senior Dev Thinking:

"Before I write any feature code, I need the foundation that everything else depends on. Config, database connection, and security are shared by EVERYTHING. If these are wrong, everything breaks."

Step 1.1 â€” requirements.txt (FIRST FILE EVER)
WHY FIRST: Defines what tools we have available
THINKING: "What libraries will I need for this whole project?"
          List ALL dependencies before starting
Step 1.2 â€” .env + core/config.py
WHY SECOND: Every other file needs config values
THINKING: "Where does sensitive data live? How do I
          keep secrets out of code? What changes
          between local and production?"

WHAT IT SOLVES:
  - Database URL differs locally vs production
  - SECRET_KEY must never be in code
  - Frontend URL differs locally vs deployed
Step 1.3 â€” core/database.py
WHY THIRD: Every service and endpoint needs DB access
THINKING: "How do I connect to PostgreSQL?
          How do I manage connection lifecycle?
          How do I avoid connection leaks?"

WHAT IT SOLVES:
  - Single engine for whole app
  - Session management
  - get_db() dependency pattern
Step 1.4 â€” core/security.py
WHY FOURTH: Auth endpoints need this immediately
THINKING: "How do I hash passwords safely?
          How do I create and decode JWT tokens?
          What goes inside a token?"

WHAT IT SOLVES:
  - bcrypt password hashing
  - JWT creation with expiry
  - Token decoding and validation
After Phase 1 you have:
backend/
â”œâ”€â”€ requirements.txt      âœ…
â”œâ”€â”€ .env                  âœ…
â””â”€â”€ app/
    â””â”€â”€ core/
        â”œâ”€â”€ config.py     âœ…
        â”œâ”€â”€ database.py   âœ…
        â””â”€â”€ security.py   âœ…

ğŸ—„ï¸ PHASE 2: Data Layer â€” "Define Your Data"
Senior Dev Thinking:

"I need to define what data I'm storing BEFORE writing any logic. Models define database tables. Schemas define what comes in and out of API. Get this right first or you'll be rewriting everything."

RULE: Models = Database shape
      Schemas = API shape
      These are different on purpose!
      
      Example: User model has hashed_password
               UserResponse schema does NOT
               (you never send password back to client)
Step 2.1 â€” models/user.py
WHY: Defines the users table in PostgreSQL
THINKING: "What do I need to know about a user?
          email (unique), password (hashed),
          name, timestamps"

RELATIONSHIPS DEFINED HERE:
  User â†’ has many â†’ Portfolio items
Step 2.2 â€” models/portfolio.py
WHY: Defines portfolio table
THINKING: "What is a portfolio item?
          Which user owns it? (foreign key)
          What coin? What quantity? What price?"

RELATIONSHIPS DEFINED HERE:
  Portfolio â†’ belongs to â†’ User
Step 2.3 â€” schemas/token.py
WHY: Needed immediately for auth responses
THINKING: "What does a token response look like?
          access_token + refresh_token + type"
Step 2.4 â€” schemas/user.py
WHY: Defines what comes IN (register/login)
     and what goes OUT (user response)
THINKING: "Registration needs email + password
          Response must NOT include password
          Use different schemas for input vs output"
Step 2.5 â€” schemas/portfolio.py
WHY: Defines portfolio API shapes
THINKING: "Create needs coin details + quantity + price
          Update only needs quantity or price (optional)
          Response includes id and timestamps
          Stats needs calculated fields"
Step 2.6 â€” schemas/crypto.py
WHY: Defines CoinGecko API response shapes
THINKING: "CoinGecko returns messy JSON
          I need clean Pydantic models
          So my API always returns consistent data"
After Phase 2 you have:
backend/
â””â”€â”€ app/
    â”œâ”€â”€ models/
    â”‚   â”œâ”€â”€ user.py        âœ…
    â”‚   â””â”€â”€ portfolio.py   âœ…
    â””â”€â”€ schemas/
        â”œâ”€â”€ token.py       âœ…
        â”œâ”€â”€ user.py        âœ…
        â”œâ”€â”€ portfolio.py   âœ…
        â””â”€â”€ crypto.py      âœ…

âš™ï¸ PHASE 3: Services â€” "Business Logic"
Senior Dev Thinking:

"Services are the heart of the application. Endpoints should be THIN (just routing). Services should be FAT (all the logic). This way I can test services independently from HTTP. If tomorrow I add a CLI instead of API, services still work."

PATTERN USED:
  API Endpoint (thin) â†’ calls â†’ Service (fat logic) â†’ calls â†’ Database/External API

WHY THIS PATTERN:
  - Services are testable without HTTP
  - Business logic in one place
  - Easy to swap database or external API later
Step 3.1 â€” services/auth_service.py
WHY FIRST SERVICE: Auth is needed by everything
THINKING: "What auth operations exist?
          create_user â†’ hash password â†’ save to DB
          authenticate_user â†’ find user â†’ verify password
          get_user_by_id â†’ used in JWT validation"
Step 3.2 â€” services/crypto_service.py
WHY SECOND: Portfolio stats need prices, WebSocket needs prices
THINKING: "This talks to CoinGecko API
          I need: search, price, details, history, overview
          Use httpx for async HTTP calls
          Handle errors gracefully (API can be slow/down)"

â­ FREE API USED HERE - CoinGecko
Step 3.3 â€” services/portfolio_service.py
WHY THIRD: Depends on models being defined
THINKING: "CRUD operations for portfolio
          get all items for user
          add item
          update item (only if user owns it)
          delete item (only if user owns it)
          
          SECURITY: Always filter by user_id
          Never let user A access user B's data"
Step 3.4 â€” services/websocket_manager.py
WHY LAST SERVICE: Depends on crypto_service
THINKING: "How do I manage multiple WebSocket connections?
          Store connections in a set
          Background task fetches prices every 10 seconds
          Broadcast to ALL connected clients
          Handle disconnected clients gracefully"
After Phase 3:
backend/
â””â”€â”€ app/
    â””â”€â”€ services/
        â”œâ”€â”€ auth_service.py       âœ…
        â”œâ”€â”€ crypto_service.py     âœ…
        â”œâ”€â”€ portfolio_service.py  âœ…
        â””â”€â”€ websocket_manager.py  âœ…

ğŸ”Œ PHASE 4: API Layer â€” "Wire It Together"
Senior Dev Thinking:

"Endpoints are just connectors. They validate input, call services, return responses. That's it. If an endpoint has more than 20 lines, something's wrong â€” move logic to a service."

Step 4.1 â€” api/deps.py
WHY FIRST: Every protected endpoint needs this
THINKING: "How does an endpoint know WHO is calling?
          
          Request â†’ Extract token from header
                  â†’ Decode JWT
                  â†’ Get user_id from payload
                  â†’ Query DB for user
                  â†’ Inject user into endpoint
          
          FastAPI's Depends() makes this automatic"
Step 4.2 â€” api/v1/auth.py
WHY SECOND: Users must exist before portfolio works
THINKING: "4 endpoints needed:
          POST /register â†’ create user â†’ return tokens
          POST /login â†’ verify credentials â†’ return tokens
          POST /refresh â†’ validate refresh token â†’ new access token
          GET /me â†’ return current user (protected)"
Step 4.3 â€” api/v1/portfolio.py
WHY THIRD: Core feature of the app
THINKING: "5 endpoints:
          GET / â†’ get all user's items
          POST / â†’ add item
          PUT /{id} â†’ update item
          DELETE /{id} â†’ delete item
          GET /stats â†’ aggregated stats
          
          ALL protected with Depends(get_current_user)"
Step 4.4 â€” api/v1/crypto.py
WHY FOURTH: Market data endpoints
THINKING: "5 endpoints:
          GET /search â†’ search coins (for add dialog)
          GET /{coin_id} â†’ coin details
          GET /{coin_id}/price â†’ current price
          GET /{coin_id}/history â†’ price history (for charts)
          GET /market/overview â†’ top coins (for dashboard)"
Step 4.5 â€” api/v1/websocket.py
WHY FIFTH: Real-time layer on top of REST
THINKING: "WebSocket is different from REST
          It's a persistent connection
          Single endpoint, manager handles everything
          Endpoint just accepts and registers connection"
Step 4.6 â€” main.py
WHY LAST: Assembles everything together
THINKING: "This is the entry point
          Register all routers
          Configure CORS (who can call my API?)
          Configure middleware
          Setup startup/shutdown events
          Start WebSocket background task"
Step 4.7 â€” Alembic Setup
WHY HERE: Models are all defined now
COMMANDS:
  alembic init alembic
  alembic revision --autogenerate -m "Initial migration"
  alembic upgrade head

THINKING: "Never modify production DB manually
          Migrations are version controlled
          Team members run same migrations"
After Phase 4 - Backend is COMPLETE:
backend/
â””â”€â”€ app/
    â”œâ”€â”€ api/
    â”‚   â”œâ”€â”€ deps.py
    â”‚   â””â”€â”€ v1/
    â”‚       â”œâ”€â”€ auth.py
    â”‚       â”œâ”€â”€ portfolio.py
    â”‚       â”œâ”€â”€ crypto.py
    â”‚       â””â”€â”€ websocket.py
    â””â”€â”€ main.py

ğŸ¨ PHASE 5: Frontend Foundation
Senior Dev Thinking:

"Frontend mirrors backend architecture. API layer first, then state management, then components. Never hardcode URLs. Always have a single axios instance. Think about state: what's global? What's local?"

STATE DECISIONS MADE UPFRONT:
  
  Global State (Context):
    - Auth user (needed everywhere)
    - WebSocket prices (needed everywhere)
  
  Local State (useState):
    - Form inputs (only in that form)
    - Dialog open/close (only in that component)
    - Loading states (only in that component)
  
  Server State (custom hooks):
    - Portfolio data (fetched, cached, refetched)
Step 5.1 â€” package.json + vite.config.js
WHY FIRST: Defines tools available
THINKING: "What do I need?
          React + Router (navigation)
          MUI (UI components)
          Axios (HTTP calls)
          Recharts (charts)
          date-fns (date formatting)"
Step 5.2 â€” .env + utils/constants.js
WHY SECOND: All API calls need the base URL
THINKING: "API URL changes between local and production
          Never hardcode http://localhost:8000
          Use environment variables
          Keep TOKEN_KEY as constant (avoid typos)"
Step 5.3 â€” utils/formatters.js
WHY THIRD: Used by almost every component
THINKING: "How do I display $45,231.50 not 45231.5?
          How do I show 1.23% not 1.23456789?
          Centralize formatting so it's consistent"
Step 5.4 â€” api/axiosInstance.js
WHY FOURTH: ALL API calls go through this
THINKING: "Every request needs the JWT token
          What happens when token expires?
            â†’ Intercept 401 response
            â†’ Try to refresh token
            â†’ Retry original request
            â†’ If refresh fails â†’ logout
          
          This is a CRITICAL file"

INTERCEPTOR FLOW:
  Request interceptor:
    Every request â†’ add "Authorization: Bearer <token>"
  
  Response interceptor:
    If 401 error:
      â†’ Get refresh token from localStorage
      â†’ Call /auth/refresh
      â†’ Save new access token
      â†’ Retry original failed request
Step 5.5 â€” api/authApi.js â†’ api/portfolioApi.js â†’ api/cryptoApi.js
WHY THESE NEXT: Services needed by contexts and hooks
THINKING: "Each API file maps to a backend router
          authApi â†’ /api/v1/auth/*
          portfolioApi â†’ /api/v1/portfolio/*
          cryptoApi â†’ /api/v1/crypto/*
          
          Functions are just axios calls
          No business logic here"
Step 5.6 â€” api/websocketClient.js
WHY HERE: Before WebSocket context
THINKING: "Encapsulate WebSocket complexity
          Handle reconnection logic
          Event handler registration
          Keep context clean"

ğŸ§© PHASE 6: Frontend State + Components
Step 6.1 â€” context/AuthContext.jsx
WHY FIRST CONTEXT: Everything depends on knowing if user is logged in
THINKING: "What does auth context provide?
          - user object (or null)
          - login() function
          - register() function
          - logout() function
          - loading state (checking token on startup)
          
          On app load â†’ check localStorage for token
                      â†’ if found â†’ call /auth/me
                      â†’ if valid â†’ set user
                      â†’ if invalid â†’ clear tokens"
Step 6.2 â€” context/WebSocketContext.jsx
WHY SECOND CONTEXT: Price data needed by multiple pages
THINKING: "Where should live prices live?
          In context â†’ so Dashboard AND Portfolio
          both get updates from ONE WebSocket
          connection (not two!)
          
          prices object: { bitcoin: {...}, ethereum: {...} }
          Components look up by coin_id"
Step 6.3 â€” hooks/usePortfolio.js
WHY BEFORE COMPONENTS: Components will use this hook
THINKING: "Portfolio data fetching logic should be
          reusable and not duplicated in components
          
          Hook manages:
            - Loading state
            - Error state
            - Fetch on mount
            - Refetch after mutations
            - Sync with WebSocket prices"
Step 6.4 â€” Common Components
ORDER:
  LoadingSpinner.jsx â†’ simplest, used everywhere
  PrivateRoute.jsx â†’ needed before routes
  Navbar.jsx â†’ displayed on all pages
Step 6.5 â€” Auth Components
ORDER:
  LoginForm.jsx â†’ register exists first (simpler)
  RegisterForm.jsx
Step 6.6 â€” Portfolio Components
ORDER:
  PortfolioStats.jsx â†’ just displays data (no logic)
  PortfolioCard.jsx â†’ displays single item
  AddCoinDialog.jsx â†’ most complex (search + form)
Step 6.7 â€” Chart Components
ORDER:
  PriceChart.jsx â†’ single coin line chart
  PortfolioChart.jsx â†’ distribution pie chart

ğŸ”— PHASE 7: Pages + App Assembly
Step 7.1 â€” Pages (Simple to Complex)
ORDER:
  Login.jsx â†’ wraps LoginForm
  Register.jsx â†’ wraps RegisterForm
  Dashboard.jsx â†’ market overview + chart
  Portfolio.jsx â†’ most complex page
Step 7.2 â€” App.jsx â€” The Final Assembly
WHY LAST: Can only be written when everything exists
THINKING: "This file answers:
          - How is the app structured?
          - Which routes exist?
          - Which routes are protected?
          - Where do context providers live?
          
          PROVIDER ORDER MATTERS:
            ThemeProvider (MUI theme)
              AuthProvider (auth state)
                Router (navigation)
                  WebSocketProvider (only in private routes)
                    Pages"
WHY WebSocketProvider INSIDE private routes?
  - WebSocket should only connect when user is logged in
  - No need to maintain WS connection on login page
  - Saves resources and avoids auth errors

ğŸŒ COMPLETE FREE API USAGE MAP
This is exactly where and how CoinGecko's free API is used:
CoinGecko Base URL: https://api.coingecko.com/api/v3
Free tier: ~30 calls/minute, no API key needed
Every CoinGecko Endpoint Used:
FILE: backend/app/services/crypto_service.py
MethodCoinGecko EndpointOur Backend EndpointUsed Bysearch_coins()GET /search?query=bitcoinGET /api/v1/crypto/searchAddCoinDialog search boxget_coin_price()GET /simple/price?ids=bitcoin&vs_currencies=usdGET /api/v1/crypto/{id}/pricePortfolioCard priceget_multiple_coin_prices()GET /coins/markets?vs_currency=usd&ids=bitcoin,ethereumGET /api/v1/crypto/market/overview + portfolio statsDashboard table + statsget_coin_details()GET /coins/bitcoinGET /api/v1/crypto/{id}Coin detail viewget_price_history()GET /coins/bitcoin/market_chart?vs_currency=usd&days=7GET /api/v1/crypto/{id}/historyPriceChart component

ğŸ—ºï¸ COMPLETE DATA FLOW DIAGRAM
                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â”‚         BROWSER                  â”‚
                        â”‚                                   â”‚
                        â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
                        â”‚  â”‚AuthContextâ”‚  â”‚WebSocketCtx  â”‚  â”‚
                        â”‚  â”‚  user    â”‚  â”‚  prices{}    â”‚  â”‚
                        â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
                        â”‚       â”‚                â”‚          â”‚
                        â”‚  â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â” â”‚
                        â”‚  â”‚         App.jsx              â”‚ â”‚
                        â”‚  â”‚    Router + Providers        â”‚ â”‚
                        â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜ â”‚
                        â”‚       â”‚                 â”‚         â”‚
                        â”‚  â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”  â”‚
                        â”‚  â”‚Dashboardâ”‚      â”‚Portfolio  â”‚  â”‚
                        â”‚  â”‚  Page   â”‚      â”‚  Page     â”‚  â”‚
                        â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â”‚
                        â”‚       â”‚                â”‚         â”‚
                        â”‚  â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â” â”‚
                        â”‚  â”‚         API Layer           â”‚ â”‚
                        â”‚  â”‚  axiosInstance (+ JWT)      â”‚ â”‚
                        â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                            â”‚ HTTP + WebSocket
                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â”‚    FASTAPI        â”‚              â”‚
                        â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
                        â”‚  â”‚         Routers             â”‚ â”‚
                        â”‚  â”‚  /auth /portfolio /crypto   â”‚ â”‚
                        â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
                        â”‚                   â”‚              â”‚
                        â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
                        â”‚  â”‚         Services            â”‚ â”‚
                        â”‚  â”‚  auth / portfolio / crypto  â”‚ â”‚
                        â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
                        â”‚         â”‚             â”‚           â”‚
                        â”‚  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
                        â”‚  â”‚PostgreSQLâ”‚   â”‚CoinGecko API â”‚ â”‚
                        â”‚  â”‚  users  â”‚   â”‚ (FREE, no keyâ”‚ â”‚
                        â”‚  â”‚portfolioâ”‚   â”‚  needed)     â”‚ â”‚
                        â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€-â”€â”˜

ğŸ’¡ KEY SENIOR DEV RULES FOLLOWED IN THIS PROJECT
1. THIN CONTROLLERS, FAT SERVICES
   Endpoints just route and validate
   Services have all logic
   
2. DEPENDENCY INJECTION
   get_db() injects database session
   get_current_user() injects user
   FastAPI's Depends() makes it automatic
   
3. SCHEMAS SEPARATE FROM MODELS
   Model = database shape (SQLAlchemy)
   Schema = API shape (Pydantic)
   Never expose raw database models to API
   
4. ENVIRONMENT VARIABLES FOR EVERYTHING SENSITIVE
   SECRET_KEY in .env
   DATABASE_URL in .env
   Never commit .env to git
   
5. SINGLE AXIOS INSTANCE
   One place for base URL
   One place for auth token
   One place for error handling
   
6. CONTEXT FOR GLOBAL STATE
   Auth state global (one user per session)
   WebSocket global (one connection for all components)
   Form state local (only that component needs it)
   
7. CUSTOM HOOKS FOR REUSABLE LOGIC
   usePortfolio() can be used in any component
   Logic is not duplicated
   
8. INTERCEPTORS FOR CROSS-CUTTING CONCERNS
   Every request needs token â†’ request interceptor
   Every 401 needs refresh â†’ response interceptor
   
9. ASYNC EVERYWHERE IN FASTAPI
   All endpoints are async
   All service calls are async
   httpx instead of requests (async HTTP)
   
10. ERROR BOUNDARIES AT EVERY LAYER
    Services catch external API errors
    Endpoints raise proper HTTPExceptions
    Frontend catches errors in try/catch
    User sees friendly error messages

ğŸ“… REALISTIC TIME ESTIMATE
Phase 1: Foundation (Backend Core)     â†’ 30 minutes
Phase 2: Data Layer (Models/Schemas)   â†’ 45 minutes
Phase 3: Services                      â†’ 1.5 hours
Phase 4: API Endpoints                 â†’ 1.5 hours
Phase 5: Frontend Foundation           â†’ 1 hour
Phase 6: Frontend State/Components     â†’ 2 hours
Phase 7: Pages + Assembly              â†’ 1.5 hours

Total: ~9 hours for a 2-year developer
       ~5 hours for a 5-year developer
       ~3 hours for a 7+ year developer

The difference is not typing speed.
It's KNOWING THE ORDER and not second-guessing decisions.

ğŸ¯ THE GOLDEN RULE
A senior developer doesn't write more code than a junior.
They write LESS code in the RIGHT ORDER
with BETTER NAMES that FUTURE DEVELOPERS can understand.

The best code is code you don't have to explain.